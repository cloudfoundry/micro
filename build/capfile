require 'net/ftp'

require 'capistrano_colors'

# Capistrano recipe for building and testing Micro Cloud Foundry from Jenkins.

# Pass these command line arguments to capistrano to set variables.
#
# -s vmrun= \
# -s vm_initial_password= \
# -s micro_password= \
# -s domain= \
# -s admin_user= \
# -s admin_password= \
# -s normal_user= \
# -s normal_password= \
# -s http_proxy= \
# -s cdn_ftp_host= \
# -s cdn_ftp_user= \
# -s cdn_ftp_password=

# ENV['BUILD_SERVER'] and ENV['TEST_SERVER'] must also be set.

load 'deploy'

role :build, ENV['BUILD_SERVER']
role :test, ENV['TEST_SERVER']

set :user, 'mmb'

ssh_options[:keys] = '/var/lib/jenkins/.ssh/id_rsa'

# Send data to virtual console 1 on a VM as if it had been typed there.
def vm_console_send(vmx_path, data, password, options={})
  options = {
    :vmrun => 'vmrun',
    :user => 'root',
    :remote_ruby => '/var/vcap/bosh/bin/ruby',
    }.merge(options)

  header = <<-eos
open('/dev/tty1', 'w') do |o|
  DATA.each_char do |c|
    o.ioctl(0x5412, c)
    sleep(rand(100) / 300.0)
  end
end
__END__
eos

  local_script = '/tmp/script.rb'
  remote_script = '/tmp/script.rb'

  open(local_script, 'w') { |f| f << header << data }

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} CopyFileFromHostToGuest \"#{vmx_path}\" #{local_script} #{remote_script}"

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} runProgramInGuest \"#{vmx_path}\" #{options[:remote_ruby]} #{remote_script}"
end

def vm_ip(vmx_path, password, options={})
  options = {
    :vmrun => 'vmrun',
    :user => 'root',
    :interface => 'eth0',
    }.merge(options)

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} runScriptInGuest \"#{vmx_path}\" /bin/sh \"/sbin/ifconfig #{options[:interface]} > /tmp/ifconfig\""

  run_locally "#{options[:vmrun]} -gu #{options[:user]} -gp #{password} CopyFileFromGuestToHost \"#{vmx_path}\" /tmp/ifconfig /tmp/ifconfig"

  `cat /tmp/ifconfig`[/inet addr:(\S+) /,1]
end

def run_commands(commands)
  run commands.join(' && ')
end

def has_tag_been_built?(tag)
  begin
    open('/var/lib/jenkins/built_tags') do |f|
      built_tags = f.readlines.map(&:chomp).reject(&:empty?)
    end
  rescue Errno::ENOENT
    built_tags = []
  end

  built_tags.include?(tag)
end

def record_tag_built(tag)
  open('/var/lib/jenkins/built_tags', 'a') do |f|
    f.write "#{tag}\n"
  end 
end

desc 'Clean up build debris.'
task :clean, :roles => :build do
  # TODO add /tmp
  run_commands([
    "#{sudo} rm -rf /var/tmp/bosh/agent-*",
    'rm -rf ~/cf-release/dev_releases/*',
    "#{sudo} rm -rf ~/bosh/agent/mcf/*",
  ])
end

desc 'Get the latest cf-release tag.'
task :latest_cf_release_tag, :roles => :build do
  run 'git --git-dir ~/cf-release/.git fetch'

  output = capture('git --git-dir ~/cf-release/.git show-ref --tags')

  tags = []

  output.lines do |line|
    match = %r{refs/tags/v(\d+)$}.match(line)
    if match
      tags << match[1].to_i
    end
  end

  "v#{tags.sort.last}"
end

desc 'Create Micro Cloud Foundry bosh release.'
task :create_release, :roles => :build do
  run_commands([
    '. ~/.bash_profile',
    'cd ~/cf-release',
    'bosh create release --force --with-tarball',
  ])
end

desc 'Update micro.'
task :update_micro, :roles => :build do
  run_commands([
    'cd ~/micro',
    'git pull',
  ])
end

desc 'Update bosh agent.'
task :update_bosh_agent, :roles => :build do
  run_commands([
    '. ~/.bash_profile',
    'cd ~/bosh/agent',
    'git pull',
    'bundle update',
  ])
end

desc 'Describe the latest commit in cf-release on the build machine.'
task :desc_cf_release, :roles => :build do
  output = capture('git --git-dir ~/cf-release/.git describe --tags').chomp
  output.gsub! /-(\d+)-[\da-z]+$/, 'p\\1'
  output
end

desc 'Checkout the latest cf-release master on the build machine.'
task :checkout_cf_release_master, :roles => :build do
  run_commands([
    'cd ~/cf-release',
    'git checkout master',
    './update'
  ])
end

desc 'Checkout a cf-release tag on the build machine.'
task :checkout_cf_release_tag, :roles => :build do
  run_commands([
    'cd ~/cf-release',
    'git fetch',
    "git checkout -b #{tag}branch #{tag}",
    'git submodule update --init --recursive'
  ])
end

desc 'Run vcap-yeti tests.'
task :bvt, :roles => :test do
  # Set the nameserver of the test machine to the Micro Cloud VM.
  resolv_conf_backup = '~/resolv.conf.backup'

  run "cp /etc/resolv.conf #{resolv_conf_backup}"
  run "echo 'nameserver #{micro_vm_ip}' > /tmp/resolv.conf"
  run "#{sudo} cp /tmp/resolv.conf /etc/resolv.conf"

  run_commands([
    '. ~/.bash_profile',
    "vmc --trace target http://api.#{domain}/",
    "vmc --trace register '#{admin_user}' --password '#{admin_password}' --verify '#{admin_password}'",
    "vmc --trace register #{normal_user} --password '#{normal_password}' --verify '#{normal_password}'",
    "export VCAP_BVT_TARGET=#{domain}",
    "export VCAP_BVT_ADMIN_USER='#{admin_user}'",
    "export VCAP_BVT_ADMIN_USER_PASSWD='#{admin_password}'",
    "export VCAP_BVT_USER='#{normal_user}'",
    "export VCAP_BVT_USER_PASSWD='#{normal_password}'",
    'cd ~/vcap-yeti',
    'env',
    './update.sh',
    'rm -rf ~/.bvt',
    'bundle exec rake full[1]'
    ])

    run "#{sudo} cp #{resolv_conf_backup} /etc/resolv.conf"
end

desc 'Distribute a nightly version of the Micro Cloud.'
task :dist_nightly do
  p "sending #{zip_local_path} to CDN #{cdn_ftp_host}/micro/nightly"

  ftp = Net::FTP.new(cdn_ftp_host, cdn_ftp_user, cdn_ftp_password)
  p ftp.putbinaryfile(zip_local_path, "micro/nightly/#{zip_name}")
  ftp.close
  p "http://download3.vmware.com/cloudfoundry/micro/nightly/#{zip_name}"
end

desc 'Distribute a release version of the Micro Cloud.'
task :dist_release do
  p "sending #{zip_local_path} to CDN #{cdn_ftp_host}/micro/release"

  ftp = Net::FTP.new(cdn_ftp_host, cdn_ftp_user, cdn_ftp_password)
  p ftp.putbinaryfile(zip_local_path, "micro/release/#{zip_name}")
  ftp.close
  p "http://download3.vmware.com/cloudfoundry/micro/release/#{zip_name}"
end

desc 'Build and test the latest Micro Cloud Foundry.'
task :build, :roles => :build do
  clean

  set :tag, latest_cf_release_tag

  if has_tag_been_built?(tag)
    checkout_cf_release_master
    release_desc = "#{tag}+"
    is_release_version = false
  else
    checkout_cf_release_tag
    release_desc = tag
    is_release_version = true
  end

  create_release
  update_bosh_agent
  update_micro

  set :build_time, Time.now.strftime('%Y%m%d.%H%M%S')
  set :version, "#{release_desc}-#{build_time}"

  run_commands([
    '. ~/.bash_profile',
    "export BUILD_TIME=#{build_time}",
    "export MCF_VERSION=#{version}",
    'export UBUNTU_ISO=~/ubuntu-10.04.4-server-amd64.iso',
    'export UBUNTU_MIRROR=http://localhost:9999/ubuntu',
    'LATEST_RELEASE=`ls -t ~/cf-release/dev_releases/micro-*-dev.tgz | head -1`',
    'cd ~/bosh/agent',
    'rake stemcell2:mcf[vsphere,~/cf-release/micro/manifest.yml,$LATEST_RELEASE]'
    ])

  build_host = find_servers_for_task(current_task)[0]

  set :zip_name, "micro-#{version}.zip"

  set :zip_local_path, "/tmp/#{zip_name}"

  zip_path = "mmb@#{build_host}:bosh/agent/mcf/#{build_time}/#{zip_name}"

  run_locally "scp #{zip_path} /tmp"

  puts run_locally "cd /tmp && unzip -o #{zip_name}"

  vmx = '/tmp/micro/micro.vmx'

  run_locally "#{vmrun} start #{vmx} nogui"

  sleep 30

  config_commands = <<-eos
1
#{micro_password}
#{micro_password}
1
#{http_proxy}
#{domain}
#{admin_user}
quit
y
eos

  vm_console_send vmx, config_commands, vm_initial_password

  # Give MCF time to boot.

  sleep 300

  # Turn on online mode.
  vm_console_send vmx, "\n6\n", micro_password

  set :micro_vm_ip, vm_ip(vmx, micro_password)

  p micro_vm_ip

  bvt

  if is_release_version
    dist_release
    record_tag_built tag
  else
    dist_nigthly
  end

  # Archive build?

  # Cleanup.

  # run_locally "#{vmrun} stop #{vmx} nogui"
  # rm -rf /tmp/micro
end
